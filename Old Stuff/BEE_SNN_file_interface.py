
import numpy

# This function encodes the spikes using bits to represent the neurons in a sequence of long integers
def set_input_neuron_bits(SpkLiq_number_of_neurons,input_list):
    '''
    SpkLiq_number_of_neurons: number of neurons
    input_list: list with the indices of the neurons that should spike (value 1)
    '''
    SpkLiq_number_of_long_ints = (SpkLiq_number_of_neurons>>6)+((SpkLiq_number_of_neurons&(64-1))>0)
    SpkLiq_test_vthres_bits = numpy.zeros(SpkLiq_number_of_long_ints,dtype=numpy.int64)
    one_int64 = numpy.array([1],dtype=numpy.int64)[0]
    for i in input_list:
        SpkLiq_test_vthres_bits[i>>6] |= (one_int64<<(i&(64-1)));
    return SpkLiq_test_vthres_bits

# So far my simulator is only working with fixed weights to the inputs.
# One reason for this is that if one is using population coding, the weights should not be changed (???).
# Another reason is a more practical one: weights are, at least, a 4 bytes value, so in a long simulation with a 
# big network the file size would became impractical very fast (one million neurons would generate 4MB per step!)
def generate_weights_file(filename, weights_array):
    output = numpy.array(weights_array, dtype=numpy.float32)
    with open(filename, "wb") as f:
            output.tofile(f)
# generate_weights_file("test_sim_exc_inputs_weights.bin", [10E-9]*(15*30*30))            

# This function generates the input file according to the input MATRIX supplied.
def generate_file(filename,number_of_neurons_liquid,input_matrix):
    with open(filename, "wb") as f:
        for i in xrange(len(input_matrix)):
            output = set_input_neuron_bits(number_of_neurons_liquid,input_matrix[i])
            output.tofile(f)
# generate_file("small_sim_exc_inputs.bin",10*2*2,[range(10*2*2)])

# This function reads an array encoded using the same scheme as set_input_neuron_bits
# and returns a numpy array with the indices of the neurons who spiked
def generate_list_from_bits(SpkLiq_number_of_neurons,input_bytes):
    output = numpy.empty(SpkLiq_number_of_neurons,dtype=numpy.int32)
    test_bits = numpy.arange(64,dtype=numpy.int64)
    count=0
    output_idx=0
    for i in input_bytes:
        for j in test_bits:
            result = (1<<(j&(64-1)))
            if (i & result):
                output[output_idx]=count*64+j
                output_idx+=1
        count+=1
    return output[:output_idx]
# generate_list_from_bits(135,set_input_neuron_bits(135,[165,32]))

# Reads the output file generated by the simulator or the input file
# and returns a numpy array where each row represents the output/input of one simulation step
# Only the indices of the neurons indicated with spike ('1') are returned.
def read_file(sim_file, SpkLiq_number_of_neurons, number_of_steps):
    SpkLiq_number_of_long_ints = (SpkLiq_number_of_neurons>>6)+((SpkLiq_number_of_neurons&(64-1))>0) 
    with open(sim_file, "rb") as f:
        return numpy.split(numpy.fromfile(f,dtype=numpy.int64,count=SpkLiq_number_of_long_ints*number_of_steps),number_of_steps)